// Generated by CoffeeScript 1.12.7
(function() {
  var ConvertImg2Svg, IsFullWidth, PixelImage, SetFontSetting, builder, createSvg, font_height, font_width, fs, getPixels, imgPath, loadFiles, main, outputPath, pixel_height, pixel_width, pixelsToPath, searchExt, settingList;

  fs = require('fs');

  getPixels = require("get-pixels");

  builder = require('xmlbuilder');

  imgPath = '../font-img';

  outputPath = '../font-svg';

  searchExt = '.json';

  settingList = void 0;

  font_width = 1024;

  font_height = 1024;

  pixel_width = 8;

  pixel_height = 8;

  loadFiles = function(dirpath, ext) {
    var files;
    fs.readdir(dirpath, function(err, files) {
      if (err) {
        console.error(err);
      }
    });
    files = fs.readdirSync(dirpath);
    files = files.filter(function(file) {
      return fs.statSync(dirpath + "/" + file).isFile() && RegExp(ext + "$").test(dirpath + '/' + file);
    });
    return files = files.map(function(file) {
      return require(dirpath + "/" + file);
    });
  };

  PixelImage = (function() {
    function PixelImage(pixels1, width1, height1) {
      this.pixels = pixels1;
      this.width = width1;
      this.height = height1;
    }

    PixelImage.prototype.getPixel = function(x, y) {
      var offset;
      offset = x * 4 + y * 4 * this.width;
      return this.pixels[offset] << 16 | this.pixels[offset + 1] << 8 | this.pixels[offset + 2];
    };

    PixelImage.prototype.getSubPixels = function(x, y, width, height) {
      var i, ref, results, x2, y2;
      results = [];
      for (y2 = i = 0, ref = height - 1; 0 <= ref ? i <= ref : i >= ref; y2 = 0 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (x2 = j = 0, ref1 = width - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; x2 = 0 <= ref1 ? ++j : --j) {
            results1.push(this.getPixel(x + x2, y + y2));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return PixelImage;

  })();

  createSvg = function(paths, setting) {
    var code, font, path, svg;
    svg = builder.create('svg', {
      encoding: 'UTF-8',
      standalone: true
    });
    svg.att({
      version: '1.1',
      xmlns: 'http://www.w3.org/2000/svg',
      width: "" + font_width,
      height: "" + font_height,
      viewBox: "0 0 " + font_width + " " + font_height
    });
    font = svg.ele('def').ele('font', {
      id: setting.name,
      'horiz-adv-x': "" + font_width
    });
    font.ele('font-face', {
      'units-per-em': "" + font_height,
      'ascent': "" + font_height,
      'descent': '0',
      'bbox': "0 0 " + font_width + " " + font_height
    });
    font.ele('missing-glyph', {
      'horiz-adv-x': "" + font_width
    });
    font.ele('glyph', {
      'unicode': '&#x20;',
      'd': '',
      'horiz-adv-x': "" + (font_width / 2)
    });
    for (code in paths) {
      path = paths[code];
      font.ele('glyph', {
        'unicode': "&#x" + (code.charCodeAt(0).toString(16)) + ";",
        'd': path
      });
    }
    return svg.end({
      pretty: true,
      indent: '  ',
      newline: '\n'
    }).replace(/&amp;/g, '&');
  };

  pixelsToPath = function(pixels, setting) {
    var _, current, i, j, path, pathStr, paths, ref, ref1, x, y;
    paths = {};
    for (y = i = 0, ref = pixels.length - 1; 0 <= ref ? i <= ref : i >= ref; y = 0 <= ref ? ++i : --i) {
      for (x = j = 0, ref1 = pixels[y].length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; x = 0 <= ref1 ? ++j : --j) {
        if (pixels[y][x] === 0) {
          if (paths[(x + 1) + "," + y + "L"] != null) {
            delete paths[(x + 1) + "," + y + "L"];
          } else {
            paths[x + "," + y + "R"] = {
              x: x,
              y: y,
              path: "R",
              used: false
            };
          }
          if (paths[(x + 1) + "," + (y + 1) + "D"] != null) {
            delete paths[(x + 1) + "," + (y + 1) + "D"];
          } else {
            paths[(x + 1) + "," + y + "U"] = {
              x: x + 1,
              y: y,
              path: "U",
              used: false
            };
          }
          if (paths[x + "," + (y + 1) + "R"]) {
            delete paths[x + "," + (y + 1) + "R"];
          } else {
            paths[(x + 1) + "," + (y + 1) + "L"] = {
              x: x + 1,
              y: y + 1,
              path: "L",
              used: false
            };
          }
          if (paths[x + "," + y + "U"]) {
            delete paths[x + "," + y + "U"];
          } else {
            paths[x + "," + (y + 1) + "D"] = {
              x: x,
              y: y + 1,
              path: "D",
              used: false
            };
          }
        }
      }
    }
    pathStr = [];
    for (_ in paths) {
      path = paths[_];
      if (!path.used) {
        current = path;
        x = path.x;
        y = path.y;
        pathStr.push("M" + (path.x * font_width / pixel_width) + " " + ((pixel_height - path.y) * font_height / pixel_height));
        while (!current.used) {
          current.used = true;
          pathStr.push(current.path);
          switch (current.path) {
            case 'U':
              y++;
              current = paths[x + "," + y + "U"] || paths[x + "," + y + "R"] || paths[x + "," + y + "D"] || paths[x + "," + y + "L"];
              break;
            case 'D':
              y--;
              current = paths[x + "," + y + "D"] || paths[x + "," + y + "L"] || paths[x + "," + y + "U"] || paths[x + "," + y + "R"];
              break;
            case 'R':
              x++;
              current = paths[x + "," + y + "R"] || paths[x + "," + y + "D"] || paths[x + "," + y + "L"] || paths[x + "," + y + "U"];
              break;
            case 'L':
              x--;
              current = paths[x + "," + y + "L"] || paths[x + "," + y + "U"] || paths[x + "," + y + "R"] || paths[x + "," + y + "D"];
          }
        }
      }
    }
    return pathStr.join('').replace(/R+/g, function(match) {
      return "h" + (match.length * font_width / pixel_width);
    }).replace(/L+/g, function(match) {
      return "h-" + (match.length * font_width / pixel_width);
    }).replace(/U+/g, function(match) {
      return "v-" + (match.length * font_height / pixel_height);
    }).replace(/D+/g, function(match) {
      return "v" + (match.length * font_height / pixel_height);
    }).replace(/[vh]-?\d+$/, 'z');
  };

  IsFullWidth = function(char, map) {
    var result;
    if (!map.length) {
      return result = false;
    } else {
      return result = map.includes(char);
    }
  };

  SetFontSetting = function(width, height) {
    if (width == null) {
      width = null;
    }
    if (height == null) {
      height = null;
    }
    if (width !== null) {
      font_width = width * 100;
      pixel_width = width;
    }
    if (height !== null) {
      font_height = height * 100;
      return pixel_height = height;
    }
  };

  ConvertImg2Svg = function(setting, imgpath, svgpath) {
    if (imgpath == null) {
      imgpath = imgPath;
    }
    if (svgpath == null) {
      svgpath = outputPath;
    }
    return getPixels(imgpath + "/" + setting.img, function(err, pixels) {
      var i, img, j, ja_map, paths, ref, ref1, x, y;
      if (err) {
        throw "Bad image path";
      }
      img = new PixelImage(pixels.data, pixels.shape[0], pixels.shape[1]);
      ja_map = setting.ja_map.flat();
      paths = {};
      for (y = i = 0, ref = setting.map.length - 1; 0 <= ref ? i <= ref : i >= ref; y = 0 <= ref ? ++i : --i) {
        for (x = j = 0, ref1 = setting.map[y].length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; x = 0 <= ref1 ? ++j : --j) {
          if (IsFullWidth(setting.map[y][x], ja_map)) {
            SetFontSetting(setting.ja_width, setting.ja_height);
            paths[setting.map[y].charAt(x)] = pixelsToPath(img.getSubPixels(x * setting.ja_width, y * setting.ja_height, setting.ja_width, setting.ja_height), setting);
          } else {
            SetFontSetting(setting.width, setting.height);
            paths[setting.map[y].charAt(x)] = pixelsToPath(img.getSubPixels(x * setting.width, y * setting.height, setting.width, setting.height), setting);
          }
        }
      }
      SetFontSetting(setting.width, setting.height);
      return fs.writeFileSync(svgpath + "/" + setting.name + ".svg", createSvg(paths, setting));
    });
  };

  main = function() {
    var i, len, setting;
    settingList = loadFiles(imgPath, searchExt);
    for (i = 0, len = settingList.length; i < len; i++) {
      setting = settingList[i];
      ConvertImg2Svg(setting);
    }
    return console.log('Convert done ...');
  };

  main();

}).call(this);
